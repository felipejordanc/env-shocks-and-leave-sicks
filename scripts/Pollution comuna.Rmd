############################################################
# Libraries
############################################################
library(haven)
library(dplyr)
library(tidyr)
library(purrr)
library(stringr)
library(broom)
library(tibble)

############################################################
# Load data
############################################################


neighbors <- read_dta("C:/Users/black/Documents/GitHub/env-shocks-and-leave-sicks/remote/data/B_intermediate/neighbors.dta")%>%
  rename(countid =entidad)

############################################################
# Helper: all non-empty subsets up to size 2 (SAFE)
############################################################
neighbor_subsets <- function(vec, max_k = 5) {

  vec <- vec[!is.na(vec)]
  k <- length(vec)

  if (k == 0) return(list())

  max_k <- min(max_k, k)

  unlist(
    lapply(1:max_k, function(m) combn(vec, m, simplify = FALSE)),
    recursive = FALSE
  )
}


############################################################
# Core imputation for one countid
############################################################
impute_one_countid <- function(df, neighbors_row, var, min_obs = 5) {

  cid <- neighbors_row$countid
  neigs <- neighbors_row %>%
    select(starts_with("neig_")) %>%
    unlist(use.names = FALSE)

  neigs <- neigs[!is.na(neigs)]

  # Subset data
  df_y <- df %>% filter(countid == cid)
  # ---- skip if target variable is entirely missing for this countid ----
  if (all(is.na(df_y[[var]]))) {
    return(list(
      data = df_y,
      meta = tibble(
        countid = cid,
        var = var,
        note = "skipped: target variable entirely missing for countid"
      )
    ))
  }


  if (length(neigs) == 0) {
    return(list(
      data = df_y,
      meta = tibble(countid = cid, var = var, note = "no neighbors")
    ))
  }

  # Build wide data: y + neighbor ys
  wide <- df_y %>%
    select(date, y = all_of(var)) %>%
    left_join(
      df %>%
        filter(countid %in% neigs) %>%
        select(date, countid, all_of(var)) %>%
        pivot_wider(
          names_from = countid,
          values_from = all_of(var),
          names_prefix = "neig_"
        ),
      by = "date"
    )

  neigh_cols <- names(wide) %>% keep(~ str_starts(.x, "neig_"))

  # Single neighbor → direct regression
  if (length(neigh_cols) == 1) {
    f <- as.formula(paste0("y ~ ", neigh_cols))
    fit <- tryCatch(lm(f, data = wide), error = function(e) NULL)

    if (is.null(fit)) {
      return(list(
        data = df_y,
        meta = tibble(countid = cid, var = var, note = "lm failed (1 neighbor)")
      ))
    }

    preds <- predict(fit, newdata = wide)

    out <- df_y %>%
      mutate(!!var := if_else(is.na(.data[[var]]), preds, .data[[var]]))

    return(list(
      data = out,
      meta = tibble(
        countid = cid,
        var = var,
        chosen_predictors = neigh_cols,
        adj_r2 = summary(fit)$adj.r.squared,
        note = "single neighbor"
      )
    ))
  }

  # ≥2 neighbors → model selection
  subsets <- neighbor_subsets(neigh_cols, max_k = 5)


  candidates <- map(subsets, function(preds) {

      df_complete <- wide %>%
        select(y, all_of(preds)) %>%
        filter(if_all(everything(), ~ !is.na(.)))
    
      if (nrow(df_complete) < min_obs) return(NULL)
    
      f <- as.formula(paste0("y ~ ", paste(preds, collapse = " + ")))
      fit <- tryCatch(lm(f, data = df_complete), error = function(e) NULL)
      if (is.null(fit)) return(NULL)
    
      tibble(
        predictors = list(preds),
        adj_r2 = summary(fit)$adj.r.squared,
        model = list(fit)
      )
    
    }) %>%
      compact() %>%
      bind_rows()


  best <- candidates %>% arrange(desc(adj_r2)) %>% slice(1)
  best_fit <- best$model[[1]]
  best_preds <- best$predictors[[1]]

  preds <- predict(best_fit, newdata = wide)

  out <- df_y %>%
    mutate(!!var := if_else(is.na(.data[[var]]), preds, .data[[var]]))

  list(
    data = out,
    meta = tibble(
      countid = cid,
      var = var,
      chosen_predictors = paste(best_preds, collapse = ", "),
      adj_r2 = best$adj_r2,
      note = "selected model"
    )
  )
}

############################################################
# Wrapper across all countids
############################################################
############################################################
# Wrapper across all countids WITH PROGRESS INDICATOR
############################################################
############################################################
# Wrapper across valid countids ONLY (with progress indicator)
############################################################
impute_by_neighbors <- function(df, neighbors, vars) {

  results <- list()
  meta <- list()

  # ---- restrict neighbors to countids present in df ----
  valid_countids <- intersect(
    unique(df$countid),
    unique(neighbors$countid)
  )

  neighbors_valid <- neighbors %>%
    filter(countid %in% valid_countids)

  for (v in vars) {

    message("Imputing variable: ", v)

    neighbors_split <- split(neighbors_valid, neighbors_valid$countid)
    n_total <- length(neighbors_split)

    out_list <- vector("list", n_total)

    for (i in seq_along(neighbors_split)) {

      nrow <- neighbors_split[[i]]
      cid <- nrow$countid

      message(
        sprintf(
          "[%s] countid %d / %d (id = %s)",
          v, i, n_total, cid
        )
      )

      out_list[[i]] <- impute_one_countid(
        df = df,
        neighbors_row = nrow,
        var = v
      )
    }

    results[[v]] <- map_dfr(out_list, "data")
    meta[[v]] <- map_dfr(out_list, "meta")
  }

  list(
    data = results[[vars[1]]],
    metadata = bind_rows(meta)
  )
}



############################################################
# RUN
############################################################

vars_to_impute <- c(
  "max_valMP10", "mean_valMP10", "median_valMP10"
)

base_path <- "C:/Users/black/Documents/GitHub/env-shocks-and-leave-sicks/remote/data/B_intermediate"

for (i in 2:20) {

  message("Processing pollution_comuna_", i)

  file_path <- file.path(
    base_path,
    paste0("pollution_comuna_", i, ".dta")
  )

  # ---- read ----
  df <- read_dta(file_path) |>
    rename(countid = Entidad)

  # ---- impute ----
  res <- impute_by_neighbors(
    df = df,
    neighbors = neighbors,
    vars = vars_to_impute
  )

  df_imputed <- res$data
  meta <- res$metadata

  # ---- write back (overwrite) ----
  write_dta(df_imputed, file_path)

  # ---- optional: save metadata ----
  write_dta(
    meta,
    file.path(
      base_path,
      paste0("pollution_comuna_", i, "_imputation_meta.dta")
    )
  )
}


