library(haven)


df <- read_dta("C:/Users/black/Documents/GitHub/env-shocks-and-leave-sicks/remote/data/B_intermediate/pollution_comuna_14.dta")
df <- df %>%
  rename(countid = Entidad,
         panelid = comb)
library(dplyr)
library(tidyr)
library(purrr)
library(stringr)
library(rsample)
library(broom)
library(tibble)

all_nonempty_subsets <- function(x) {
  unlist(
    lapply(seq_along(x), function(k) {
      combn(x, k, simplify = FALSE)
    }),
    recursive = FALSE
  )
}

fit_and_eval <- function(y, xmat, train_frac) {
  n <- length(y)
  idx <- seq_len(n)
  train_n <- floor(train_frac * n)
  train_idx <- sample(idx, train_n)

  y_tr <- y[train_idx]
  y_te <- y[-train_idx]

  x_tr <- xmat[train_idx, , drop = FALSE]
  x_te <- xmat[-train_idx, , drop = FALSE]

  fit <- tryCatch(
    lm.fit(x = cbind(1, x_tr), y = y_tr),
    error = function(e) NULL
  )
  if (is.null(fit)) return(NULL)

  preds <- cbind(1, x_te) %*% fit$coefficients

  ss_res <- sum((y_te - preds)^2)
  ss_tot <- sum((y_te - mean(y_te))^2)

  r2 <- 1 - ss_res / ss_tot
  rmse <- sqrt(mean((y_te - preds)^2))

  p <- ncol(x_tr)
  n_te <- length(y_te)

  r2adj <- if (n_te - p - 1 > 0) {
    1 - (1 - r2) * ((n_te - 1) / (n_te - p - 1))
  } else {
    NA_real_
  }

  list(
    fit = fit,
    r2 = r2,
    rmse = rmse,
    r2adj = r2adj
  )
}

impute_one_comuna <- function(
  df_comuna,
  var,
  panelid_col = "panelid",
  countid_col = "countid",
  date_col = "date",
  metric = c("r2adj", "r2", "rmse"),
  train_frac = 0.8,
  min_obs = 10,
  verbose = TRUE,
  seed = 123
) {
  metric <- match.arg(metric)
  set.seed(seed)

  wide <- df_comuna |>
    select(all_of(c(date_col, countid_col, var))) |>
    pivot_wider(
      id_cols = all_of(date_col),
      names_from = all_of(countid_col),
      values_from = all_of(var)
    ) |>
    arrange(.data[[date_col]])

  mat <- as.matrix(wide[, -1])
  colnames(mat) <- colnames(wide)[-1]

  panel_map <- df_comuna[, c(panelid_col, countid_col)] |>
    distinct() |>
    group_by(.data[[panelid_col]]) |>
    summarise(
      countids = list(as.character(.data[[countid_col]])),
      .groups = "drop"
    )

  panels <- panel_map[[panelid_col]]
  panel_to_cols <- setNames(panel_map$countids, panels)

  mat_imp <- mat
  metadata <- list()

  for (target_panel in panels) {
    target_countids <- panel_to_cols[[target_panel]]
    other_panels <- setdiff(panels, target_panel)
    if (length(other_panels) == 0) next

    panel_sets <- all_nonempty_subsets(other_panels)

    for (cid in target_countids) {
      if (verbose) {
        message(
          "[", unique(df_comuna$cod_comuna),
          "] panel ", target_panel,
          " | imputing countid ", cid
        )
      }

      y <- mat[, cid]
      miss <- is.na(y)
      if (!any(miss)) next

      best <- NULL

      for (ps in panel_sets) {
        pred_cols <- unlist(panel_to_cols[ps])
        valid <- !is.na(mat[, pred_cols[1]])
        keep <- valid & !miss
        if (sum(keep) < min_obs) next

        fe <- fit_and_eval(
          y = y[keep],
          xmat = mat[keep, pred_cols, drop = FALSE],
          train_frac = train_frac
        )
        if (is.null(fe)) next

        score <- switch(
          metric,
          r2adj = fe$r2adj,
          r2 = fe$r2,
          rmse = -fe$rmse
        )
        
        if (!is.finite(score)) next
        
        if (is.null(best) || score > best$score) {
          best <- list(
            pred_panels = ps,
            pred_cols = pred_cols,
            fit = fe$fit,
            score = score
          )
        }

      }

      if (is.null(best)) next

      pred_rows <- miss & !is.na(mat[, best$pred_cols[1]])
      x_new <- mat[pred_rows, best$pred_cols, drop = FALSE]
      preds <- cbind(1, x_new) %*% best$fit$coefficients
      mat_imp[pred_rows, cid] <- preds

      metadata[[length(metadata) + 1]] <- tibble(
        cod_comuna = unique(df_comuna$cod_comuna),
        panelid = target_panel,
        countid = cid,
        predictors = paste(best$pred_panels, collapse = "+"),
        metric = metric,
        score = best$score,
        n_predicted = sum(pred_rows)
      )
    }
  }

  wide_imp <- wide
  wide_imp[, -1] <- mat_imp

  long_imp <- wide_imp |>
    pivot_longer(
      -all_of(date_col),
      names_to = countid_col,
      values_to = var
    ) |>
    mutate(!!countid_col := as.integer(.data[[countid_col]]))

  list(
    imputed_long = df_comuna |>
      select(-all_of(var)) |>
      left_join(long_imp, by = c(date_col, countid_col)),
    metadata = bind_rows(metadata)
  )
}

impute_hierarchical <- function(
  df,
  var,
  metric = "r2adj",
  verbose = TRUE
) {
  comuna_groups <- df |>
    group_by(cod_comuna) |>
    group_split()

  results <- map(
    comuna_groups,
    function(g) {
      impute_one_comuna(
        df_comuna = g,
        var = var,
        metric = metric,
        verbose = verbose
      )
    }
  )

  list(
    data = bind_rows(map(results, "imputed_long")),
    metadata = bind_rows(map(results, "metadata"))
  )
}

vars_to_impute <- c("max_valMP25")

res <- impute_hierarchical(
  df = df,
  var = vars_to_impute,
  metric = "r2adj",
  verbose = TRUE
)

df_imputed <- res$data |>
  arrange(cod_comuna, panelid, countid, date)

meta <- res$metadata


