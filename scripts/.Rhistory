imputed_long = replaced,
metadata = bind_rows(metadata_list)
)
}
# ============================================================
# Top-level wrapper: run for multiple vars across comunas
# Defaults set to your column names
# ============================================================
impute_by_comuna <- function(
df,
comuna_col = "cod_comuna",
panelid_col = "panelid_col",
countid_col = "countid",
date_col = "date",
vars,
train_frac = 0.8,
metric = c("r2", "rmse", "r2adj"),
seed = 123,
min_obs = 5,
verbose = TRUE
) {
metric <- match.arg(metric)
comuna_groups <- df %>% group_by(.data[[comuna_col]]) %>% group_split()
results_per_var <- list()
metadata_all <- list()
for (v in vars) {
if (verbose) message("Processing variable: ", v)
imputed_comunas <- map(comuna_groups, function(comuna_df) {
impute_variable_for_one_comuna(
comuna_df = comuna_df,
comuna_col = comuna_col,
panelid_col = panelid_col,
countid_col = countid_col,
date_col = date_col,
var = v,
train_frac = train_frac,
metric = metric,
seed = seed,
min_obs = min_obs
)
})
results_per_var[[v]] <- map_dfr(imputed_comunas, "imputed_long")
metadata_all[[v]]   <- map_dfr(imputed_comunas, "metadata") %>% mutate(target_var = v)
}
# Merge imputed results back into original dataframe (only replace NA)
df_final <- df
for (v in vars) {
df_var <- results_per_var[[v]] %>%
select(all_of(c(comuna_col, panelid_col, date_col, countid_col, v)))
df_final <- df_final %>%
left_join(df_var, by = c(comuna_col, panelid_col, date_col, countid_col), suffix = c("", ".new")) %>%
mutate(
!!v := if_else(is.na(.data[[v]]) & !is.na(.data[[paste0(v, ".new")]]),
.data[[paste0(v, ".new")]],
.data[[v]])
) %>%
select(-all_of(paste0(v, ".new")))
}
list(
data = df_final,
metadata = bind_rows(metadata_all, .id = "variable")
)
}
vars_to_impute <- c("max_valMP25")
res2 <- impute_by_comuna(
df = df,
comuna_col = "cod_comuna",
panelid_col = "panelid_col",
countid_col = "countid",
date_col = "date",
vars = vars_to_impute,
train_frac = 0.8,
metric = "r2adj",
seed = 2025,
min_obs = 5,
verbose = TRUE
)
rlang::last_trace()
rlang::last_trace(drop = FALSE)
# ============================================================
# Defensive helper: all non-empty subsets of vector
# Guarantees vec is a clean character vector and length(vec) is valid
# ============================================================
all_nonempty_subsets <- function(vec) {
# ensure character, remove NA and empty strings
vec <- as.character(vec)
vec <- vec[!is.na(vec)]
vec <- vec[nchar(vec) > 0]
# safe length check
if (length(vec) == 0 || is.na(length(vec))) return(list())
combos <- list()
for (k in seq_len(length(vec))) {
# utils::combn expects a proper vector and integer k
cm <- utils::combn(vec, k, simplify = FALSE)
combos <- c(combos, cm)
}
combos
}
# ============================================================
# Fit lm on training set, test on test set (returns r2, rmse, r2_adj_test)
# ============================================================
fit_and_eval <- function(formula, train_df, test_df) {
model <- tryCatch(lm(formula, data = train_df), error = function(e) NULL)
if (is.null(model)) return(NULL)
preds <- tryCatch(predict(model, newdata = test_df), error = function(e) NULL)
if (is.null(preds)) return(NULL)
y_test <- test_df[[all.vars(formula)[1]]]
ss_res <- sum((y_test - preds)^2)
ss_tot <- sum((y_test - mean(y_test, na.rm = TRUE))^2)
r2_test <- if (ss_tot == 0) NA_real_ else 1 - ss_res / ss_tot
rmse_test <- sqrt(mean((y_test - preds)^2))
p <- length(attr(stats::terms(formula), "term.labels"))
n_test <- nrow(test_df)
if (is.na(r2_test) || (n_test - p - 1) <= 0) {
r2_adj_test <- NA_real_
} else {
r2_adj_test <- 1 - (1 - r2_test) * ((n_test - 1) / (n_test - p - 1))
}
list(
model = model,
r2_test = r2_test,
rmse_test = rmse_test,
r2_adj_test = r2_adj_test
)
}
# ============================================================
# Core: impute one variable for one comuna (with robust checks)
# ============================================================
impute_variable_for_one_comuna <- function(
comuna_df,
comuna_col = "cod_comuna",
panelid_col = "panelid_col",
countid_col = "countid",
date_col = "date",
var,
train_frac = 0.8,
metric = c("r2", "rmse", "r2adj"),
seed = 123,
min_obs = 5
) {
metric <- match.arg(metric)
set.seed(seed)
comuna_val <- unique(comuna_df[[comuna_col]])
panels <- sort(unique(comuna_df[[panelid_col]]))
# Skip comuna if only one panel
if (length(panels) <= 1) {
return(list(
imputed_long = comuna_df,
metadata = tibble(
comuna = comuna_val,
var = var,
panelid = NA_character_,
note = "skipped: comuna has only 1 panel"
)
))
}
# ------------------------------------------------------------
# Safe pivot: pivot only the target var into var_panelid_countid columns
# ------------------------------------------------------------
pivoted <- comuna_df %>%
mutate(
!!countid_col := as.integer(.data[[countid_col]]),
colname = paste0(var, "_", .data[[panelid_col]], "_", .data[[countid_col]])
) %>%
select(all_of(c(comuna_col, date_col, "colname", var))) %>%
pivot_wider(
id_cols = c(all_of(comuna_col), all_of(date_col)),
names_from = colname,
values_from = all_of(var)
) %>%
arrange(.data[[date_col]])
# Defensive: build var_cols reliably and remove NA/empty names
var_cols <- names(pivoted)
var_cols <- var_cols[str_starts(var_cols, paste0(var, "_"))]
var_cols <- var_cols[!is.na(var_cols) & nchar(var_cols) > 0]
pivoted_imputed <- pivoted
metadata_list <- list()
# ------------------------------------------------------------
# Loop panels in comuna
# ------------------------------------------------------------
for (panel in panels) {
panel_prefix <- paste0(var, "_", panel, "_")
y_cols <- var_cols[str_starts(var_cols, fixed(panel_prefix))]
y_cols <- y_cols[!is.na(y_cols) & nchar(y_cols) > 0]
if (length(y_cols) == 0) {
metadata_list[[paste0(panel, "_no_ycols")]] <- tibble(
comuna = comuna_val,
panelid = panel,
var = var,
note = "skipped: no y columns after pivot"
)
next
}
# Skip panel if it has no missing values across its monitors
any_missing <- any(map_lgl(y_cols, ~ any(is.na(pivoted[[.x]]))))
if (!any_missing) {
metadata_list[[paste0(panel, "_skipped_nomiss")]] <- tibble(
comuna = comuna_val,
panelid = panel,
var = var,
note = "skipped: panel has no missing values"
)
next
}
# predictors are columns from other panels
predictor_cols_all <- setdiff(var_cols, y_cols)
# sanitize predictors
predictor_cols_all <- predictor_cols_all[!is.na(predictor_cols_all) & nchar(predictor_cols_all) > 0]
predictor_cols_all <- as.character(predictor_cols_all)
if (length(predictor_cols_all) == 0) {
metadata_list[[paste0(panel, "_nopreds")]] <- tibble(
comuna = comuna_val,
panelid = panel,
var = var,
note = "skipped: no predictors from other panels"
)
next
}
# ----------------------------------------------------------
# Loop each y_col of this panel
# ----------------------------------------------------------
for (y_col in y_cols) {
# Skip if y_col is entirely missing (can't train on it), but keep its X columns for others
if (all(is.na(pivoted[[y_col]]))) {
metadata_list[[paste0(panel, "_", y_col, "_allyNA")]] <- tibble(
comuna = comuna_val,
panelid = panel,
var = var,
y_col = y_col,
note = "skipped: y column fully missing (kept as predictor for others)"
)
next
}
# Generate candidate subsets defensively
candidate_list <- all_nonempty_subsets(predictor_cols_all)
if (length(candidate_list) == 0) {
metadata_list[[paste0(panel, "_", y_col, "_nocands")]] <- tibble(
comuna = comuna_val,
panelid = panel,
var = var,
y_col = y_col,
note = "skipped: no candidate predictor subsets"
)
next
}
# --- metadata: best single predictor stats
single_counts <- map_int(predictor_cols_all, function(pred) {
sum(!is.na(pivoted[[y_col]]) & !is.na(pivoted[[pred]]))
})
if (all(single_counts == 0)) {
best_single_idx <- 1L
} else {
best_single_idx <- which.max(single_counts)
}
best_single_pred <- predictor_cols_all[best_single_idx]
n_best_single_countid_val <- single_counts[best_single_idx]
n_predicted_best_single_countid_val <- sum(is.na(pivoted[[y_col]]) & !is.na(pivoted[[best_single_pred]]))
# --- metadata: best subset coverage
subset_counts <- map_int(candidate_list, function(preds) {
preds <- as.character(preds)
preds <- preds[!is.na(preds) & nchar(preds) > 0]
if (length(preds) == 0) return(0L)
sum(!is.na(pivoted[[y_col]]) & apply(!is.na(pivoted %>% select(all_of(preds))), 1, all))
})
n_best_subset_countid_val <- if (length(subset_counts) == 0) 0L else max(subset_counts, na.rm = TRUE)
# ----------------------------------------------------------
# Evaluate candidate models: 80/20 CV, only keep ones that can predict >=1 missing row
# ----------------------------------------------------------
candidate_info <- list()
for (pred_set in candidate_list) {
pred_set <- as.character(pred_set)
pred_set <- pred_set[!is.na(pred_set) & nchar(pred_set) > 0]
if (length(pred_set) == 0) next
can_predict <- sum(is.na(pivoted[[y_col]]) & apply(!is.na(pivoted %>% select(all_of(pred_set))), 1, all)) >= 1
if (!can_predict) next
complete_rows <- pivoted %>% select(all_of(c(y_col, pred_set))) %>% filter(if_all(everything(), ~ !is.na(.)))
if (nrow(complete_rows) < min_obs) next
split <- rsample::initial_split(complete_rows, prop = train_frac)
train_df <- rsample::training(split)
test_df <- rsample::testing(split)
formula <- as.formula(paste0("`", y_col, "` ~ ", paste0("`", pred_set, "`", collapse = " + ")))
fe <- fit_and_eval(formula, train_df, test_df)
if (is.null(fe)) next
candidate_info[[length(candidate_info) + 1]] <- list(
predictors = pred_set,
formula = formula,
r2_test = fe$r2_test,
rmse_test = fe$rmse_test,
r2_adj_test = fe$r2_adj_test,
n_train = nrow(train_df),
n_test = nrow(test_df),
n_complete = nrow(complete_rows)
)
} # end candidate loop
if (length(candidate_info) == 0) {
metadata_list[[paste0(panel, "_", y_col, "_nocandidate")]] <- tibble(
comuna = comuna_val,
panelid = panel,
var = var,
y_col = y_col,
note = "skipped: no valid candidates (or insufficient complete rows)",
n_best_single_countid = n_best_single_countid_val,
n_best_subset_countid = n_best_subset_countid_val,
n_predicted = 0L,
n_predicted_best_single_countid = n_predicted_best_single_countid_val
)
next
}
# ----------------------------------------------------------
# Rank candidates by chosen metric
# ----------------------------------------------------------
cand_df <- tibble(candidate = candidate_info) %>%
mutate(
r2    = map_dbl(candidate, ~ .x$r2_test),
rmse  = map_dbl(candidate, ~ .x$rmse_test),
r2adj = map_dbl(candidate, ~ .x$r2_adj_test)
)
order_idx <- if (metric == "r2") {
order(-cand_df$r2, na.last = TRUE)
} else if (metric == "r2adj") {
order(-cand_df$r2adj, na.last = TRUE)
} else {
order(cand_df$rmse, na.last = TRUE)
}
candidate_sorted <- cand_df$candidate[order_idx]
# ----------------------------------------------------------
# Refit each candidate on all available complete rows for that subset
# ----------------------------------------------------------
refitted <- list()
for (ci in seq_along(candidate_sorted)) {
cinfo <- candidate_sorted[[ci]]
preds_clean <- as.character(cinfo$predictors)
preds_clean <- preds_clean[!is.na(preds_clean) & nchar(preds_clean) > 0]
if (length(preds_clean) == 0) next
full_complete_rows <- pivoted %>% select(all_of(c(y_col, preds_clean))) %>% filter(if_all(everything(), ~ !is.na(.)))
if (nrow(full_complete_rows) == 0) next
full_model <- tryCatch(lm(cinfo$formula, data = full_complete_rows), error = function(e) NULL)
if (is.null(full_model)) next
refitted[[length(refitted) + 1]] <- list(
predictors = preds_clean,
formula = cinfo$formula,
r2_test = cinfo$r2_test,
rmse_test = cinfo$rmse_test,
r2_adj_test = cinfo$r2_adj_test,
n_train = cinfo$n_train,
n_test = cinfo$n_test,
n_complete = nrow(full_complete_rows),
full_model = full_model
)
} # end refit
if (length(refitted) == 0) {
metadata_list[[paste0(panel, "_", y_col, "_norefitted")]] <- tibble(
comuna = comuna_val,
panelid = panel,
var = var,
y_col = y_col,
note = "skipped: no refitted models",
n_best_single_countid = n_best_single_countid_val,
n_best_subset_countid = n_best_subset_countid_val,
n_predicted = 0L,
n_predicted_best_single_countid = n_predicted_best_single_countid_val
)
next
}
# ----------------------------------------------------------
# Greedy per-row imputation
# ----------------------------------------------------------
pivoted_with_row <- pivoted_imputed %>% mutate(row_id = row_number())
imputed_flags <- rep(FALSE, nrow(pivoted_with_row))
total_predicted <- 0L
for (rc in seq_along(refitted)) {
rc_info <- refitted[[rc]]
preds_cols <- rc_info$predictors
eligible <- pivoted_with_row %>%
filter(is.na(.data[[y_col]])) %>%
filter(if_all(all_of(preds_cols), ~ !is.na(.)))
if (nrow(eligible) == 0) next
eligible <- eligible %>% filter(!imputed_flags[row_id])
if (nrow(eligible) == 0) next
newdata <- eligible %>% select(all_of(preds_cols))
preds <- tryCatch(predict(rc_info$full_model, newdata = newdata), error = function(e) rep(NA_real_, nrow(newdata)))
pivoted_imputed[eligible$row_id, y_col] <- preds
success_idx <- which(!is.na(preds))
if (length(success_idx) > 0) {
imputed_row_ids <- eligible$row_id[success_idx]
imputed_flags[imputed_row_ids] <- TRUE
total_predicted <- total_predicted + length(success_idx)
}
} # end rc loop
# ----------------------------------------------------------
# Metadata for this y_col
# ----------------------------------------------------------
top_refit <- refitted[[1]]
metadata_list[[paste0(panel, "_", y_col)]] <- tibble(
comuna = comuna_val,
panelid = panel,
var = var,
y_col = y_col,
formula = deparse(top_refit$formula),
r2_test = top_refit$r2_test,
rmse_test = top_refit$rmse_test,
r2_adj_test = top_refit$r2_adj_test,
n_train = top_refit$n_train,
n_test = top_refit$n_test,
n_complete_best_model = top_refit$n_complete,
n_best_single_countid = n_best_single_countid_val,
n_best_subset_countid = n_best_subset_countid_val,
n_predicted = total_predicted,
n_predicted_best_single_countid = n_predicted_best_single_countid_val,
note = NA_character_
)
} # end y_col loop
} # end panel loop
# ------------------------------------------------------------
# Convert pivoted_imputed back to long and join to comuna_df
# ------------------------------------------------------------
long_imputed <- pivoted_imputed %>%
pivot_longer(cols = starts_with(paste0(var, "_")),
names_to = "col",
values_to = paste0(var, "_imputed")) %>%
mutate(
tmp = str_remove(col, paste0("^", var, "_")),
panelid = sub("^(.*?)_.*$", "\\1", tmp),
countid = as.integer(sub("^.*?_(.*)$", "\\1", tmp))
) %>%
select(-col, -tmp)
replaced <- comuna_df %>%
left_join(long_imputed, by = c(comuna_col, date_col, "panelid", "countid")) %>%
mutate(
!!var := if_else(is.na(.data[[var]]) & !is.na(.data[[paste0(var, "_imputed")]]),
.data[[paste0(var, "_imputed")]],
.data[[var]])
) %>%
select(-all_of(paste0(var, "_imputed")))
list(
imputed_long = replaced,
metadata = bind_rows(metadata_list)
)
}
# ============================================================
# Top-level wrapper: run for multiple vars across comunas
# ============================================================
impute_by_comuna <- function(
df,
comuna_col = "cod_comuna",
panelid_col = "panelid_col",
countid_col = "countid",
date_col = "date",
vars,
train_frac = 0.8,
metric = c("r2", "rmse", "r2adj"),
seed = 123,
min_obs = 5,
verbose = TRUE
) {
metric <- match.arg(metric)
comuna_groups <- df %>% group_by(.data[[comuna_col]]) %>% group_split()
results_per_var <- list()
metadata_all <- list()
for (v in vars) {
if (verbose) message("Processing variable: ", v)
imputed_comunas <- map(comuna_groups, function(comuna_df) {
impute_variable_for_one_comuna(
comuna_df = comuna_df,
comuna_col = comuna_col,
panelid_col = panelid_col,
countid_col = countid_col,
date_col = date_col,
var = v,
train_frac = train_frac,
metric = metric,
seed = seed,
min_obs = min_obs
)
})
results_per_var[[v]] <- map_dfr(imputed_comunas, "imputed_long")
metadata_all[[v]]   <- map_dfr(imputed_comunas, "metadata") %>% mutate(target_var = v)
}
# Merge imputed results back into original dataframe (only replace NA)
df_final <- df
for (v in vars) {
df_var <- results_per_var[[v]] %>%
select(all_of(c(comuna_col, panelid_col, date_col, countid_col, v)))
df_final <- df_final %>%
left_join(df_var, by = c(comuna_col, panelid_col, date_col, countid_col), suffix = c("", ".new")) %>%
mutate(
!!v := if_else(is.na(.data[[v]]) & !is.na(.data[[paste0(v, ".new")]]),
.data[[paste0(v, ".new")]],
.data[[v]])
) %>%
select(-all_of(paste0(v, ".new")))
}
list(
data = df_final,
metadata = bind_rows(metadata_all, .id = "variable")
)
}
res2 <- impute_by_comuna(
df = df,
comuna_col = "cod_comuna",
panelid_col = "panelid_col",
countid_col = "countid",
date_col = "date",
vars = vars_to_impute,
train_frac = 0.8,
metric = "r2adj",
seed = 2025,
min_obs = 5,
verbose = TRUE
)
gc()
gc()
